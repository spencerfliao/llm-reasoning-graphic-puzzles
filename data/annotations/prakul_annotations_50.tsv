Filename	Reflections	Pixel/Object Changes	Helper Functions	Program Instructions
855e0971.png	The task involves extending the pixels into columns with their height limited to the colored portions of the input grid they are inside.	Pixels are changed into columns.	get_objects can be used to get the pixels. fill_between_coords can be used to extend the pixels vertically till they reach the height of the colored portion in the input grid.	1. obtain the pixels 2. extend the pixels vertically to cover the height of the colored portion the pixel is in.
995c5fa3.png	The task involves creating a three by three output grid by filling its three rows with colors as per the pattern in the three parts of the input grid.	The objects are identified by dividing the input grid using the gray columns into three parts. If the object looks like the shape 'H' rotated 90 degrees, it is mapped with green color, solid gray block is mapped with red, 'O' looking object is mapped to gray and 'A' looking object is mapped with yellow.	get_objects can be used to get the pixels. fill_row can be used to color the row in the output grid. 	1. obtain the three objects 2. fill the row of the output grid with the color based on the shape of the object.
868de0fa.png	The task involves filling up the blue grids with a color depending on whether the side length is an even or an odd number.	The objects are defined by the blue grids. The objects are filled with orange color if the size of one side of the grid is an odd value else filled with red color.	get_objects can be used to obtain the objects. fill_rect can be used to fill up the objects with colors.	1. obtain the objects 2. fill the objects with the color as per the even or off value of the size of the grid.
8731374e.png	The task involves identifying the largest block of some color having a few different colored pixels inside it and then extending those pixels across the height and width of the block.	The object is the largest block of some color. Pixels of same color as the original ones are added to the existing pixels across the height and width of the block.	get_objects can be used to identify the largest block and then the pixels inside it. get_pixel_coords can be used to get the value and coordinates of the pixels. fill_between_coords can be used to extend the pixels across the height and width of that block.	1. get the object 2. get the pixels 3. extend the pixels vertically and horizontally to cover the height and width of the block.
8a004b2b.png	The task involves transforming the object inside the grid formed by the four yellow pixels as corners into the object outside the yellow pixel grid.	Pixels are added to the object inside the grid formed by yellow pixels to match the object outside the yellow pixel grid. The pixels are added after scaling up the object until the common pixels become the same size.	get_objects can be used to get the objects. crop_grid can be used to just return the grid portion formed used the four yellow pixels as corners. fill_between_coords can be used to fill the pixels to match the object outside the yellow grid. 	1. obtain the objects 2. crop the grid to just include the portion inside the four yellow pixels 3. fill the pixels in the object to match it with the scaled up object outside the yellow pixel grid.
8be77c9e.png	The task involves combining the input grid with its mirror image about the bottom edge.	The height of the input grid is doubled. The lower half of the output grid is the vertically mirrored version of the input grid.	vertical_flip can be used to obtain a mirrored image of the input grid. combine_object can be used to combine the mirrored grid with the original grid 	1. get the mirrored image of the input grid. 2. combine the mirrored image with the input grid to get the output grid.
8d5021e8.png	The task involves combining the input grid with its mirror image along the left edge. Then replicating the pattern two more times and combining them on top of each other to get an output that is three times the height and two times the width.	The object is repeated six times so the number of pixels become six times the input grid.	horizontal_flip can be used to get the mirror image of the input grid along its left edge. combine_object can be used to combine the two images. vertical_flip can be used to mirror the resulting object twice. 	1. get the mirrored image of the input grid along its left edge. 2. combine the mirrored image with the input grid. 3. take the mirror image of the combined image twice, along the bottom axis. 4. combine the resulting three images on top of each other.
8d510a79.png	The task involves extending the pixels to form columns that connect with either the grid edge or the gray row depending on the color of the pixel.	Pixels are added to form a column connecting either the grid edge or the gray row.	get_objects can be used to get all the objects. get_pixel_coords can be used to get the color of the pixels. fill_between_coords can be used to fill the values between the pixel and the chosen edge.	1. get the objects 2. check the color of the pixel 3. if the pixel is above the gray row and is blue, extend it vertically to the top edge of the grid. If pixel is red, extend it vertically to the gray row. If the pixel is below the gray row and blue, extend it vertically to the bottom edge of the grid.
8e1813be.png	The task involves building the output grid using rows with colors corresponding to the colors of the rows in the input grid.	The object created is an n by n square where n is the number of rows and each row has a color corresponding to the color of the row in the input grid.	get_pixel_coords can be used to get the color of the rows. fill_row can be used to fill the rows with the corresponding colors.	1. get the number of colored rows in input grid 2. fill the rows of the n by n output grid with colors corresponding to the color of the rows in the input grid
8e5a5113.png	The task involves an input grid that is divided by gray columns into three parts. It requires filling the second and the third part of the input grid with the first part of the grid. The second part is a 90 degree clockwise rotated image of the first part and the third part is the 90 degree clockwise rotated image of the second part.	The object is transformed by rotating it 90 degrees and 180 degrees clockwise.	get_objects can be used to get the colored object that will be used for filling the rest of the grid. rotate_clockwise can be used to rotate the object first 90 degrees and then 180 degrees.	1. obtain the colored object 2. rotate the colored object by 90 degrees clockwise and copy it on the second part. 3. rotate the original object 180 degrees clockwise and copy it on the third part.
99b1bc43.png	The task involves the input grid being divided by the yellow line into two three by three squares. The output is calculated by merging the two squares in such a way that the pixel position relative to the centre of the squares is colored only if it is missing from one square and is present in the other square.	The objects in the input grid are the two three by three squares that are formed by dividing the input grid using the yellow line. The pixels for each corresponding pixel position in the squares are checked. If the pixel position is present in both squares, or if the pixel position is absent in both squares, then the pixel in output is not colored. If the pixel position is present in one square and is absent in the other square, then it is colored in the output square. The output grid is a three by three square whose pixels are colored green.	get_objects can be used to identify the two squares in the input grid. combine_object_negative can be used to merge the two squares to get the output square.	1. obtain the two squares in the input grid. 2. combine the two squares such that the pixel is colored only if it is present in just one of the two squares. 3. color the pixels green
8efcae92.png	The task involves selecting the blue grid that contains the maximum number of red pixels.	The object are the blue portions of the grid.  	get_objects can be used to get the blue grids. get_pixel_coords can be used to get the number of red pixels inside a blue grid.	1. obtain the objects 2. count the number of red pixels in each grid 3. the object with the most number of red pixels forms the output grid.
913fb3ed.png	The task involves enclosing the pixel in a colored square based on its color.	The objects are the pixels. The green, gray and red pixels are enlcosed in the square of colors pink, yellow and blue respectively 	get_objects can be used to get the pixels. enclose_pixel can be used to add a square around the pixel.	1. obtain the objects 2. enclose the objects with a square of a corresponding color.
91714a58.png	The task involves identifying a rectangle or a square that is formed by using more than 1 pixel in both length and width.	The object is the rectangle of any color that has more than one pixel in each of its two dimensions.	get_objects can be used to get the objects	1. obtain the object 2. remove everything else from the input grid
9172f3a0.png	The task involves scaling up the input grid by a factor of 3. 	The object is the input grid which is scaled up three times	enlarge_grid can be used to scale up the grid.	1. scale up the input grid by a factor of 3
941d9a10.png	The task involves coloring the central, top left, and bottom right unselected portions of the input grid.	The top left is filled with blue, central with red and bottom right is filled with green.	get_pixel_coords can be used to get the unselected portions of the input grid. fill_value can be used to fill in the corresponding values based on the position.	1. obtain the coordinates of the top left, central and bottom right portion of the input grid. 2. fill values based on the corresponding colors.
952a094c.png	The task involves translating the colored pixels inside the colored square to the outside and diagonally opposite ends of the square.	The pixels are in the interior corners of the colored square. They are moved to the diagonally opposite and outer ends of the square.	get_pixel_coords can be used to get the pixel values and coordinates. 	1. obtain the pixels in the interior corners of the square 2. move them to their diagonally opposite ends in the outer region of the square.
9565186b.png	The task involves identifying the pixel values that are a majority and graying everything else out.	The object is the collection of pixels that are most abundant.	get_objects can be used to get the object. fill_value can be used to fill the values gray	1. obtain the object. 2. gray out the pixels not part of the object.
95990924.png	The task involves coloring the outer pixels on the corner along the diagonal of the gray blocks.  	The objects are the gray blocks. The top right pixel is colored as red, bottom right is yellow, bottom left is green and top left is blue.	get_objects can be used to get the gray objects. fill_value can be used to color the pixels on the corners.	1. obtain the object 2. fill the pixel on the corners with the responding colors.
963e52fc.png	The task involves combining the input grid with its replica along the right edge.	The objects are doubled as the two similar objects are joined.	get_objects can be used to get the input grid. replicate_object can be used to get a copy of the object and combine_object can be used to combine them.	1. get the input grid 2. replicate the input grid 3. combine the two objects along the right edge.
97999447.png	The task involves extending the pixel horizontally till it reaches the right edge of the input grid. The extension follows the alternating pattern of colored and grayed pixel.	The pixels are added while extending the original pixel to the right edge. The alternating pattern involves the color of the pixel and gray color.	get_pixel_coords to get the coordinates and values of the pixel. fill_between_coords to fill the values till the right edge but in an alternating fashion.	1. get the pixels. 2. extend the pixel till the right edge alternatively coloring it with the pixel color and gray color.
98cf29f8.png	The task involves combining two objects based on which object forms the connection and make it adjacent to the main object.	There is a main object that is a rectangle. The other object is also a rectangle but with an extended row or column connecting it to the main object. The sizes of the objects remain the same.	get_objects can be used to get the objects.	1. obtain the objects and identify which object is the main and which is forming the connection. 2. move the connecting object adjacent to the main object.
99fa7670.png	The task involves extending the pixels to the right edge of the grid and on reaching the end, continue extending it to the bottom of the edge unless it reaches a colored pixel or the bottom edge.	The pixels of the same color are added while extending the initial pixel.	get_objects can be used to get the objects. fill_between_coords can be used to extend the initial pixel to join the grid edge.	1. obtain the objects 2. extend the pixel to the right most edge of the grid. 3. extend it vertically downwards till it reaches either a colored pixel or the bottom most edge
a2fd1cf0.png	The task involves connecting the red and green dots using one horizontal and vertical line each.	The pixels are added to connect the dots. 	get_pixel_coords can be used to get the coordinates of the red and the green pixels. fill_between_coords can be used to connect the two pixels with one horizontal line and one vertical line.	1. obtain the coordinates of the red and green pixels. 2. add pixels to the red dot horizontally. 3. They should be added on the left if the green pixel is on the left else added to the right. 4. Once the pixel value reaches the same column as that of the green pixel, add pixels vertically to the connect to the green pixel.
a48eeaf7.png	The task involves moving the gray pixels to the red object along the column or the row that directly connects them.	The red block is the main object. The gray pixels are moved and palced adjacent to the main object along the row or column connecting the main object to the gray pixel.	get_objects can be used to identify the red object and get_pixel_coords can be used to get the pixel coorinates of the gray pixels. fill_value can be used to fill the values of the adjacent pixels.	1. obtain the red object. 2. obtain the coordinates of the gray pixels. 3. move the gray pixels from their initial position to directly adjacent to the main object along the row or column connected directly with them. 4. moving is done by filling the value of the pixel directly adjacent to the main block in that same row or column and removing the value from the initial position.
a61f2674.png	The task involves identifying the longest and the shortest gray columns and coloring them.	The objects are the gray columns. The tallest column is colored blue and the shortest one is colored red.	get_objects can be used to identify the gray objects. fill_object can be used to color the columns.	1. obtain the objects 2. identify the longest and the shortest objects 3. color the longest column blue and the shortest column as red.
a8d7556c.png	The task involves identifying any square or rectangle formed by more than one pixel in length and width each and coloring them red.	The objects are squares or rectangles that have both dimensions having more than one pixel. The objects are then changed into red color.	get_objects can be used to find out the group of pixels. get_pixel_coords can be used to understand the pattern of the pixels and identify which of them form either a square or a rectangle. fill_object can be used to color the objects red.	1. obtain the objects that are either square or rectangle. 2. color the objects red
aabf363d.png	The task involves coloring the object same as the bottom left cell.	There is only one object which only changes in color based on the bottom left cell of the input grid. In the output grid, the bottom left cell is colored black.	get_objects can be used to find out the object. get_pixel_coords can be used to get the value of the bottom left pixel. fill_object can be used to color the object with the same value as the bottom left pixel. 	1. obtain the object 2. get the value of the bottom left most pixel. 3. color the object with the same value. 4. color the bottom left most pixel back to black,
a9f96cdd.png	The task involves placing four different colored pixels on the grid such that each one appears at the corner of the single red pixel in the input. The colored pixels are placed on the diagonal positions of the red pixel.	The top left pixel is green colored, top right is pink, bottom left is gray and bottom rught is orange. The pixels are added to the output grid by keeping the relative position of the red pixel same. The output grid does not contain red pixel but just the four colored pixels.	get_pixel_coords can be used to identify the red pixel position in the grid. fill_value can be used to add the four different clored pixels at the four corners of where the red pixel  was supposed to be in the output grid.	1. obtain the red pixel coordinates. 2. add the four differently colored pixels at the diagonally outer corners of the red pixel. 3. color the red pixel black.
a3325580.png	The task involves identifying the objects that are present with the highest number of pixels in them and then arranging colored columns in the output grid that appear in the order when we move from left edge to right edge. The height of the output grid is equal to the number of pixels in the identified objects.	The objects are the ones that have the highest number of pixels in them. They can be more than one but the pixel number should be the highest. The order of the colors is determined as how they appear in the grid relative to the left edge of the grid. The output grid is an m by n grid where m is the highest number of pixels and n is the number of objects that share that number of pixels.	get_objects can be used to obtain the objects and also the number of pixels in each object. fill_col can be used to fill the columns in the output grid with the values based on the order of the object's pixel values.	1. obtain the objects 2. add column for each object if there are multiple objects having the highest number of pixels.
ac0a08a4.png	The task involves scaling up the input grid by a factor equal to the number of colored pixels.	Each pixel is scaled up to form an n by n square where n is the number of colored pixels in the input grid. The output grid is of size 3n by 3n.	get_pixel_coords can be used to get the values of the colored pixels using which we can know the number of colored pixels. enlarge_grid can be used to scale up the input grid.	1. obtain the number of colored pixels, say n. 2. enlarge the input grid by a factor of n.
ae4f1146.png	The task involves selecting one of the light blue objects having the maximum number of indigo blue pixels. 	The objects are 3 by 3 squares that are a combination of light and indigo blue pixels.	get_objects can be used to identify the 3 by 3 squares of blue pixels. get_pixel_coords can be used to calculate the number of indigo blue pixels.	1. obtain the objects. 2. calculate the number of indigo blue pixels in each object. 3. select the object with the maximum number of indigo blue pixels.
aedd82e4.png	The task involves coloring a red pixel blue that does not have any other red pixel directly adjacent to it.	The pixel color is changed from red to blue if that pixel is not adjacent to any other red pixel.	get_pixel_coords can be used to obtain the pixel values and coordinates. fill_value can be used to color the pixels blue.	1. obtain the pixel values and coordinates. 2. identify red pixels that are not adjacent to any other red pixel on any of the four sides. 3. color those red pixels blue.
af902bf9.png	The task involves inserting a red block between the four yellow pixels such that if we connect the yellow pixels to form a rectangle, the red block stays completely inside it.  	An object is defined by a group of four yellow pixels such that if we connect them by filling pixels in rows and columns, it forms either a square or a rectangle. The objects never coincide with each other and stay separate. The pixels that are strictly inside the edges of the so formed square or rectangle using the four yellow pixels are colored red.	get_objects can be used to identify a set of four yellow pixels that form an object. fill_value or fill_rectangle can be used to insert a red block of size n by n where n can have any value starting from one.	1. obtain the objects. 2. insert an n by n red colored block in the object where n can be any value starting with one.
b6afb2da.png	The task involves coloring the gray objects in a pattern. The pattern is defined as four corners being colored blue, the edges connecting the corners are colored yellow, and the rest of the pixels inside are colored red,	The objects are the gray blocks in the input grid. Each object is colored in a pattern. The four corner pixels are colored blue. The pixels of the edges connecting the four corner pixels are colored yellow. The rest of the gray pixels are colored red.	get_objects can be used to obtain the gray objects. fill_value can be used to color the corner pixels blue. fill_between_coords can be used to fill the pixels with yellow color. fill_rect can be used to color the gray block inside the yellow edges with red.	1. obtain the objects. 2. color the corners with blue. 3. color the edges that connect the corners yellow. 4. color the inside gray pixels red.
b8cdaf2b.png	The task involves identifying all the colored pixels that have no colored pixel directly adjacent to their sides and coloring them black.	The pixels are identified by checking their adjacent pixels. If a colored pixel does not share any of the four sides with any other colored pixel, then that pixel is colored black.	get_pixel_coords can be used to obtain the values and coordinates of the colored pixels. fill_value can be used to color the selected pixels black. 	1. obtain the pixel values and coordinates of the colored pixels. 2. identify the colored pixels that do not have any other colored pixel directly adjacent to them. 3. color those pixels black.
b9b7f026.png	The task involves identifying the color of the object that has one or more black pixels inside it and returning one pixel of that color as the output. 	Any colored block is identified as an object. The objects are either a square or a rectangle. One of the object has a black pixel or a square or a rectangle completely inside it.	get_objects can be used to obtain the obejcts. get_objects can again be used to identify a black square or a rectangle inside each colored object. fill_value can be used to color a pixel with the same color as the selected object. 	1. obtain the colored objects. 2. identify the colored object that contains a black object inside it. 3. return one pixel as output with its color same as that of the identified object.
ba97ae07.png	The task involves changing the pixels where the horizontal band intersects the vertical band, such that the overlaid band now underlies the other. If the vertical band originally appeared on top, it is changed so that the horizontal band is on top, and vice versa.	The values of the pixels change based on which band, vertical or horizontal, is on the top. If in the input grid, the pixel values pertain to the vertical band, they are changed to the values pertaining to the horizontal band and vice versa.	get_pixel_coords can be used to get the values and the coordinates of the pixels at the intersection. fill_value or fill_rect can be used to change the values of the intersecting pixels.	1. obtain the pixel values and coordinates of the intersecting pixels. 2. change the color of the pixels from its original color to the color corresponding to the underlaid band.
bb43febb.png	The task involves coloring the interior of a gray object, defined as the shape formed by reducing the object's length and breadth by one pixel, leaving a border of one pixel width in gray around it.	The object is defined by the gray blocks present in the input grid. If the object is of size m by n, the inner part of the object of shape m-1 by n-1 is colored red.	get_objects can be used to get the gray objects. fill_rect or fill_value can be used to color the shape formed by reducing the object's length and breadth by one pixel with red.	1. obtain the gray objects 2. identify the shape formed by reducing the object's length and breadth by one pixel. 3. color that shape with red.
bbc9ae5d.png	The task involves observing the sequence of pixel values in the first row then starting from the third row, coloring the entire row with the color corresponding to the pixel values sequence in first row. The coloring of the rows in a sequence is repeated twice. 	The pixel colors for each row starting from the third row are changed to match the color as observed in the sequence of pixel values in the first row. The pattern of rows starting from the third row is repeated twice. 	get_pixel_coords can be used to obtain the pixel values and coordinates of the sequence of pixels in the first row. fill_between_coords can be used to fill the rows with the color matching the sequence of the pixels in the first row.	1. obtain the pixel values and coordinates of the pixel sequence in the first row. 2. color the rows starting from third row with the colors matching the same sequence. 3. Repeat the pattern again.
bda2d7a6.png	The task involves identifying the order of the pixel values as you move from the outermost one-pixel-wide square shape of size n by n to the next n-1 by n-1 square and so on till you reach the central two by two square. Then shifting the color order of the pixel values by 1 to the right, while keeping the shapes same, such that the pixel value of the n by n square is now the pixel value for the n-1 by n-1 square.	The pixel values are changed to shift the order of the colors of the squares by one to the right as we move right from the outermost square to the innermost square.	get_pixel_coords can be used to get the pixel values and coordinates as we move from the outermost square to the innermost square. fill_between_coords can be used to fill the values in the squares in the shifted sequence as we move from the outermost square to the innermost square.	1. obtain the pixel values and coordinates from the sqaures in the input grid as we move right from the outmost square to the innermost one. 2. shift the sequence of the pixel values by one to the right. 3. color the squares in the shifted sequence as we move right from the outmost square to the innermost one.
bdad9b1f.png	The task involves extending the pixels that form a small part of a row and a column until they form the complete row and column. The pixel at the intersection is colored yellow.	The pixel values are added in order to extend the colored pixels to form a complete row and a column. The intersection pixel is colored yellow while the extended row and column follow the same color as the row and the column.	get_pixel_coords can be used to get the values and the position of the pixels. fill_between_coords can be used to color the extension of the row and the column based on their color.	1. obtain the pixel values. 2. extend the parts of the column and the row by adding pixels of the same color. 3. Color the intersected pixel yellow.
be94b721.png	The task involves selecting the biggest object in the input grid and giving it as an output.	The object is identified by the group of pixels of the same values in the inout grid.	get_objects can be used to get the objects in the input grid. get_pixel_coords can be used to identify the biggest object	1. obtain the objects 2. output the biggest object in the input grid as the output.
b7249182.png	The task involves extending the two colored pixels in the input grid such that they connect together after forming a tuning fork shaped object.	The pixels are extended by adding pixels of the same color to them. The tuning fork shape has a base of five pixels and a height of two pixels. 	get_pixel_coords can be used to get the pixel values and coordinates of the two pixels in the input grid. fill_between_coords can be used to generate the tuning fork shapes.	1. obtain the pixel values and coordinates. 2. extend the pixel so as to connect them to each other. 3. connect the two extended lines using the tuning fork shape in the end.
ba26e723.png	The task involves inserting magenta columns after every two columns starting with the first column.	The column is created by changing the yellow pixels to magenta without changing the black pixels. The columns are modified in the pattern of first column, fourth column, seventh column and so on, until the entire input grid is covered.	get_objects can be used to get the coordinates for the sequence of columns in the input grid. fill_between_coords can be used to colore the columns in the sequence from yellow to magenta.	1. obtain the coordinates of the columns forming a sequence of one, four, seven and so on. 2. color the yellow pixels into magenta.
b782dc8a.png	The task involves a maze like structure in the input grid formed using gray color. The starting pixel is colored with the adjacent black pixels colored with another color. It involves coloring the black pixels in the same alternating color pattern until the black path reaches an end and cannot go further.	The pixels are added in an alternating pattern and only the black continuously connected pixels are colored in this pattern until the end is reached and no further black pixel is present. The other black pixels that are not connected to the black pixels containing the starting poit remain unchanged.	get_pixel_coords can be used to get the mae structure to identify the continuous path made by black pixels. fill_value can be used to color those black pixels in an alternating pattern based on the colors of the starting pixels.	1. obtain the maze structure to identify the continuous paths formed using black pixels. 2. obtain the pixel colors of the starting pixel and its adjacent pixels. 3. color the path by continuing the alternating pattern until an end is reached.
b1948b0a.png	The task involves changing the values of magenta tiles into pink without changing any other pixels.	The magenta pixels are converted to red pixels while the orange pixels remain the same.	get_pixel_coords can be used to get the pixel values of the magenta pixels. fill_value can be used to change the color of the magenta pixels into red pixels.	1. obtain the magenta pixels 2. color them red
b230c067.png	The task involves identifying the three gray objects and coloring the two identical ones blue and the different one red	The objects are defined by the gray shapes in the input grid. The two shapes that are identical are colored blue and the different one is colored red.	get_objects can be used to get the gray shapes in the input grid. It can also be used to check if the corresponding positions of the pixels combine to form identical shapes. fill_object can be used to color the object blue or red.	1. obtain the gray objects. 2. identify which two of them are identical. 3. color the identical objects blue and the different one red.
b2862040.png	The task involves identifying the blue objects that form a closed loop and coloring them gray while keeping the rest of the pixels in the input grid unchanged.	The objects are defined by the blue shapes in the input grid. The shapes that form a closed figure similar to 'O' or '0' or '9' are colored gray.	get_objects can be used to get all the blue objects and also which of the objects form a closed loop by looking at the pixel coordinates. fill_object can be used to color the selected object gray.	1. obtain the blue objects. 2. identify the shapes with a closed loop in them. 3. color the identified shapes gray.
b94a9452.png	The task involves swapping the two different colors of the pixels of the object with each other.	The object is a square that is formed with pixels of two different colors. The pixel values are swapped with each other. The output is just the square having the swapped colors.	get_objects can be used to get the squares and the pixel values in the object. fill_value can be used to swap the pixel values for each pixel in the object from the original color to the other color in the object. crop_grid can be used to keep the output as the square and removing the black pixels.	1. obtain the square object. 2. identify the two pixel values that form the object. 3. swap the pixel values 4. crop the output grid to just have the square with the swapped colors.